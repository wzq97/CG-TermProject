<!DOCTYPE html>
<html lang="en">
	<head>
		<script src="js/three.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/FirstPersonControls.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/FBXLoader.js"></script>
		<script src="js/inflate.min.js"></script>
	</head>
	<body>
		<script>

			var camera, scene, renderer;

			var floorGeometry, floorMaterial, floorMesh, floorTexture;
			var boxGeometry, boxMaterial, boxMesh, boxTexture;
			var controls;
			var light;

			var loadingManager;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			var buildings = [];
			var houses = [];
			var street;
			var street_v;
			var acs = [];
			var lights = [];
			var blackboard;
			var rotation = [0, -Math.PI/2, -Math.PI, -3*Math.PI/2];

			//======================================
			var mapWidth = 15;
			var mapHeight = 15;
			var buildingFootprint = 37;
			var mapGrid = [];
			var streetNum = 3;
			//======================================

			function init() {

				//camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				// camera = new THREE.OrthographicCamera( window.innerWidth/-8, window.innerWidth / 8, window.innerHeight / 8, window.innerHeight / - 8, -1000, 1000 );
				// camera.position.X = 20;
				// camera.position.y = 15;
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1500 );
				camera.position.X = 200;
				camera.position.y = 400;
    			camera.position.z = 200;
				//camera.position.set( 500, 600, 500 );
				//camera.lookAt (buildingFootprint*mapWidth*100/2,0,buildingFootprint*mapWidth/2);

				// 
				loadingManager = new THREE.LoadingManager();

				// SCENE
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				scene.fog = new THREE.Fog( 0x000000, 600, 1300 );

				// Create a HemisphereLight source
				// light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				// light.position.set( 0, 400, 400 );
				// scene.add( light );

				// light2 = new THREE.DirectionalLight( 0xffffff, 1.0 );
				// light2.castShadow = true;
				//light2.shadow = new THREE.LightShadow(camera);
				//light2.shadow.bias = 0.0001;
				//light2.shadow.mapSize.width = 2048 * 2;
				//light2.shadow.mapSize.height = 2048 * 2;
				//scene.add( light2 );
				
				var light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );

				// Create a WebGL Renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio * 1);
				//renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;
				// Set the size of the renderer to the inner width and inner height of the window
				renderer.setSize( window.innerWidth, window.innerHeight );
				// Add in the created DOM element to the body of the document
				document.body.appendChild( renderer.domElement );

				// const cameraHelper = new THREE.CameraHelper(light2.shadow.camera);
				// scene.add(cameraHelper);

				// Create First Person Controls
				//controls = new THREE.FirstPersonControls( camera );
				//scene.add( controls.getObject() );
				
				// orbit control
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;
				controls.screenSpacePanning = true;
				controls.minDistance = 200;
				controls.maxDistance = 700;
				controls.maxPolarAngle = Math.PI / 2;
				controls.target.set( buildingFootprint*mapWidth/2, 20, buildingFootprint*mapWidth/2 );

				// Create FLOOR
				// var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				// mesh.rotation.x = - Math.PI / 2;
				// mesh.receiveShadow = true;
				// scene.add( mesh );
				
				// GRID
				// var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				// grid.material.opacity = 0.2;
				// grid.material.transparent = true;
				// grid.receiveShadow = true;
				// scene.add( grid );
				
				// LOAD models
				loadModels();

				loadingManager.onLoad = function ( ) {
					console.log( 'Loading complete!');
					buildGrid();
					generateAlley();
				};
				// PUT models into the scene
				//generateAlley();
				
				

			}

			function animate() {

				// Call the requestAnimationFrame function on the animate function
				requestAnimationFrame( animate );
				//console.log(buildings.length);
				controls.update();
				// Check the FirstPersonControls object and update velocity accordingly
				//playerControls();

				//controls.getObject().translateX(0.1 );

				// Render everything using the created renderer, scene, and camera
				renderer.render( scene, camera );

			}

			// load my models for alley
			function loadModels() {
				
				var loader = new THREE.FBXLoader(loadingManager);
				loader.load( 'models/shop1.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/shop2.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/shop3.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				// loader.load( 'models/shop4.fbx', function ( object ) {
				// 	buildings.push(object);
				// }, undefined, function ( e ) {
				// 	console.error( e );
				// } );
				// loader.load( 'models/shop5.fbx', function ( object ) {
				// 	buildings.push(object);
				// }, undefined, function ( e ) {
				// 	console.error( e );
				// } );
				loader.load( 'models/house1.fbx', function ( object ) {
					houses.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/house2.fbx', function ( object ) {
					houses.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );

				loader.load( 'models/ac.fbx', function ( object ) {
					acs.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/ac1.fbx', function ( object ) {
					acs.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/ac2.fbx', function ( object ) {
					acs.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );

				loader.load( 'models/light1.fbx', function ( object ) {
					lights.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/light2.fbx', function ( object ) {
					lights.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/light3.fbx', function ( object ) {
					lights.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/light4.fbx', function ( object ) {
					lights.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );

				// loader.load( 'models/ground.fbx', function ( object ) {
				// 	object.castShadow = true;
				// 	object.receiveShadow = true;
				// 	scene.add( object );
				// }, undefined, function ( e ) {
				// 	console.error( e );
				// } );
				loader.load( 'models/street.fbx', function ( object ) {
					street = object;
					object.castShadow = true;
					object.receiveShadow = true;
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/street_v.fbx', function ( object ) {
					street_v = object;
				}, undefined, function ( e ) {
					console.error( e );
				} );


				loader.load( 'models/blackboard.fbx', function ( object ) {
					blackboard = object;
				}, undefined, function ( e ) {
					console.error( e );
				} );
			}

			function randInt(min, max) { // min and max included 
				return Math.floor(Math.random() * (max - min + 1) + min);
			}

			function buildGrid() {
				for(var i = 0; i < mapWidth; i++){
					mapGrid.push([]);
				}
				for(var i = 0; i < mapGrid.length; i++){
					//mapGrid[i] = [];
					for(var j = 0; j < mapHeight; j++){
						mapGrid[i][j] = 1;	// building
					}
				}
				var x = 0;
				for(var s = 0; s < streetNum; s++){
					for(var j = 0; j < mapHeight; j++){
						mapGrid[x][j] = -1; 
					}
					x += randInt(2,5);
					if(x >= mapWidth) break;
				}
				var z = 0;
				for(var s = 0; s < streetNum; s++){
					for(var i = 0; i < mapWidth; i++){
						if(mapGrid[i][z] == -1){
							mapGrid[i][z] = -3
						}
						else{
							mapGrid[i][z] = -2;
						}
					}
					z += randInt(2,5);
					if(z >= mapHeight) break;
				}
			}

			// generate a map
			function generateAlley() {
				var b,h,s,sv,sh,a,l,rot;
				var board;
				for(var i = 0; i < mapWidth; i++){
					for(var j = 0; j < mapHeight; j++){
						var result = mapGrid[i][j];
						var pos = [i * buildingFootprint, j * buildingFootprint];

						if(result < -2){	//crossstreet
							s = street.clone();
							s.castShadow = true;
							s.receiveShadow = true;
							s.translateX(pos[0]);
							s.translateZ(pos[1]);
							scene.add( s );
						}
						else if(result < -1 ){
							sv = street_v.clone();
							sv.castShadow = true;
							sv.receiveShadow = true;
							sv.translateX(pos[0]);
							sv.translateZ(pos[1]);
							scene.add( sv );

							var r0 = randInt(0,3);
							if(r0 == 0){
								board = blackboard.clone();
								board.castShadow = true;
								board.receiveShadow = true;
								board.translateX(pos[0]);
								board.translateZ(pos[1]);
								scene.add( board );	
							}			
						}
						else if( result < 0 ){
							s = street.clone();
							s.castShadow = true;
							s.receiveShadow = true;
							s.translateX(pos[0]);
							s.translateZ(pos[1]);
							scene.add( s );
						}
						else
						{
							if(checkneighbor(i,j)){
								var r = randInt(0,buildings.length-1);	// randomly choose a building
								b = buildings[r].clone();
								b.castShadow = true;
								b.receiveShadow = true;
								b.translateX(pos[0]);
								b.translateZ(pos[1]);
								//rot = rotation[randInt(0,3)];
								rot = rotation[checkOrientation(i,j)];
								b.rotation.y = rot;
								scene.add( b );

								var newLight = new THREE.PointLight( 0xFFFFAA, 1, 100 );
								newLight.position.set( pos[0], 20, pos[1] );
								scene.add( newLight );

								// var sphereSize = 1;
								// var pointLightHelper = new THREE.PointLightHelper( newLight, sphereSize );
								// scene.add( pointLightHelper );

								// add the house aboveshop
								var r2 = randInt(0,houses.length-1);
								h = houses[r2].clone();
								h.castShadow = true;
								h.receiveShadow = true;
								h.translateX(pos[0]);
								h.translateZ(pos[1]);
								h.rotation.y = rot;
								scene.add( h );

								// add ac
								var r0 = randInt(0,1);
								if(r0 == 0){
									var r3 = randInt(0,acs.length-1);
									a = acs[r3].clone();
									a.castShadow = true;
									a.receiveShadow = true;
									a.translateX(pos[0]);
									a.translateZ(pos[1]);
									a.translateY(randInt(-2,10));
									a.rotation.y = rot;
									scene.add( a );
								}
								r0 = randInt(0,1);
								if(r0 == 0){
									var r4 = randInt(0,lights.length-1);
									l = lights[r4].clone();
									l.castShadow = true;
									l.receiveShadow = true;
									l.translateX(pos[0]);
									l.translateZ(pos[1]);
									l.translateY(randInt(-5,5));
									l.rotation.y = rot;
									scene.add( l );
								}
							}
							else{
								continue;
							}
							
						}
						
					}
				}
			}
			// return true can place a house(8 grid around is all house then false)
			function checkneighbor(row,col){
				if(row < 1 || col < 1 || row > mapWidth-2 || col > mapHeight-2){
					return true;
				}
				if(mapGrid[row-1][col-1] < 0){
					return true;
				}
				else if(mapGrid[row-1][col] < 0){
					return true;
				}
				else if(mapGrid[row-1][col+1] < 0){
					return true;
				}
				else if(mapGrid[row][col-1] < 0){
					return true;
				}
				else if(mapGrid[row][col+1] < 0){
					return true;
				}
				else if(mapGrid[row+1][col-1] < 0){
					return true;
				}
				else if(mapGrid[row+1][col] < 0){
					return true;
				}
				else if(mapGrid[row+1][col+1] < 0){
					return true;
				}
				return false;
			}
			function checkOrientation(row,col){
				if(col < 1){
					return 2;
				}
				else if(col > mapHeight-2){
					return 0;
				}
				else if(row < 1){
					return 1;
				}
				else if(row > mapWidth-2){
					return 3;
				}
				if(mapGrid[row-1][col-1] < 0 && mapGrid[row-1][col] < 0 && mapGrid[row-1][col+1] < 0){
					return 1;
				}
				else if(mapGrid[row][col-1] < 0 && mapGrid[row-1][col-1] < 0 && mapGrid[row+1][col-1] < 0){
					return 2;
				}
				else if(mapGrid[row+1][col-1] < 0 && mapGrid[row+1][col] < 0 && mapGrid[row+1][col+1] < 0){
					return 3;
				}
				return 0;
			}

			function playerControls () {

				// Are the controls enabled? (Does the browser have pointer lock?)
				if ( controls.controlsEnabled ) {

					// Save the current time
					var time = performance.now();
					// Create a delta value based on current time
					var delta = ( time - prevTime ) / 1000;

					// Set the velocity.x and velocity.z using the calculated time delta
					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					// As velocity.y is our "gravity," calculate delta
					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					if ( controls.moveForward ) {
						velocity.z -= 400.0 * delta;
					}

					if ( controls.moveBackward ) {
						velocity.z += 400.0 * delta;
					}

					if ( controls.moveLeft ) {
						velocity.x -= 400.0 * delta;
					}

					if ( controls.moveRight ) {
						velocity.x += 400.0 * delta;
					}

					// Update the position using the changed delta
					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					// Prevent the camera/player from falling out of the 'world'
					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

					}

					// Save the time for future delta calculations
					prevTime = time;

				}
			}

			init();
			animate();

		</script>
	</body>
</html>