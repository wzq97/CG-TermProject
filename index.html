<!DOCTYPE html>
<html lang="en">
	<head>
		<script src="js/three.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/FirstPersonControls.js"></script>
		<script src="js/FBXLoader.js"></script>
		<script src="js/inflate.min.js"></script>
	</head>
	<body>
		<script>

			var camera, scene, renderer;

			var floorGeometry, floorMaterial, floorMesh, floorTexture;
			var boxGeometry, boxMaterial, boxMesh, boxTexture;
			var controls;
			var light;

			var loadingManager;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			var buildings = [];
			var houses = [];
			var street;
			var rotation = [0, -Math.PI/2, -Math.PI, -3*Math.PI/2];

			//======================================
			var mapWidth = 12;
			var mapHeight = 12;
			var buildingFootprint = 37;
			var mapGrid = [];
			var streetNum = 5;
			//======================================

			function init() {

				// Create a camera
				// 	Set a Field of View (FOV) of 75 degrees
				// 	Set an Apsect Ratio of the inner width divided by the inner height of the window
				//	Set the 'Near' distance at which the camera will start rendering scene objects to 2
				//	Set the 'Far' (draw distance) at which objects will not be rendered to 1000
				//camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera = new THREE.OrthographicCamera( window.innerWidth/-8, window.innerWidth / 8, window.innerHeight / 8, window.innerHeight / - 8, -1000, 1000 );
				camera.position.X = 20;
				camera.position.y = 15;
				
				// 
				loadingManager = new THREE.LoadingManager();

				// SCENE
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0 );
				scene.fog = new THREE.Fog( 0xa0a0a0, 400, 1000 );

				// Create a HemisphereLight source
				// light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				// light.position.set( 0, 400, 400 );
				// scene.add( light );

				light2 = new THREE.DirectionalLight( 0xffffff, 1.0 );
				//light2.position.set( 0, 500, 100 );
				light2.castShadow = true;
				//light2.shadow = new THREE.LightShadow(camera);
				//light2.shadow.bias = 0.0001;
				//light2.shadow.mapSize.width = 2048 * 2;
				//light2.shadow.mapSize.height = 2048 * 2;
				scene.add( light2 );

				// const cameraHelper = new THREE.CameraHelper(light2.shadow.camera);
				// scene.add(cameraHelper);

				// Create First Person Controls
				controls = new THREE.FirstPersonControls( camera );
				scene.add( controls.getObject() );

				// Create FLOOR
				// var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				// mesh.rotation.x = - Math.PI / 2;
				// mesh.receiveShadow = true;
				// scene.add( mesh );
				
				// GRID
				// var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				// grid.material.opacity = 0.2;
				// grid.material.transparent = true;
				// grid.receiveShadow = true;
				// scene.add( grid );
				
				// LOAD models
				loadModels();

				loadingManager.onLoad = function ( ) {
					console.log( 'Loading complete!');
					buildGrid();
					generateAlley();
				};
				// PUT models into the scene
				//generateAlley();
				
				// Create a WebGL Renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio * 1);
				//renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;
				// Set the size of the renderer to the inner width and inner height of the window
				renderer.setSize( window.innerWidth, window.innerHeight );
				// Add in the created DOM element to the body of the document
				document.body.appendChild( renderer.domElement );

			}

			function animate() {

				// Call the requestAnimationFrame function on the animate function
				requestAnimationFrame( animate );
				//console.log(buildings.length);

				// Check the FirstPersonControls object and update velocity accordingly
				playerControls();

				//controls.getObject().translateX(0.1 );

				// Render everything using the created renderer, scene, and camera
				renderer.render( scene, camera );

			}

			// load my models for alley
			function loadModels() {
				
				var loader = new THREE.FBXLoader(loadingManager);
				loader.load( 'models/shop1.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				// loader.load( 'models/shop2.fbx', function ( object ) {
				// 	buildings.push(object);
				// }, undefined, function ( e ) {
				// 	console.error( e );
				// } );
				// loader.load( 'models/shop3.fbx', function ( object ) {
				// 	buildings.push(object);
				// }, undefined, function ( e ) {
				// 	console.error( e );
				// } );
				// loader.load( 'models/shop4.fbx', function ( object ) {
				// 	buildings.push(object);
				// }, undefined, function ( e ) {
				// 	console.error( e );
				// } );
				// loader.load( 'models/shop5.fbx', function ( object ) {
				// 	buildings.push(object);
				// }, undefined, function ( e ) {
				// 	console.error( e );
				// } );
				loader.load( 'models/house1.fbx', function ( object ) {
					houses.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/ac.fbx', function ( object ) {
					//houses.push(object);
					object.castShadow = true;
					object.receiveShadow = true;
					object.translateX(100);
					object.translateZ(100);

						//scene.add( object );
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/ground.fbx', function ( object ) {
					object.castShadow = true;
					object.receiveShadow = true;
					scene.add( object );
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/street.fbx', function ( object ) {
					street = object;
					object.castShadow = true;
					object.receiveShadow = true;
				}, undefined, function ( e ) {
					console.error( e );
				} );
			}

			function randInt(min, max) { // min and max included 
				return Math.floor(Math.random() * (max - min + 1) + min);
			}

			function buildGrid() {
				for(var i = 0; i < mapWidth; i++){
					mapGrid.push([]);
				}
				for(var i = 0; i < mapGrid.length; i++){
					//mapGrid[i] = [];
					for(var j = 0; j < mapHeight; j++){
						mapGrid[i][j] = 1;	// building
					}
				}
				var x = 0;
				for(var s = 0; s < streetNum; s++){
					for(var j = 0; j < mapHeight; j++){
						mapGrid[x][j] = -1; 
					}
					x += randInt(2,5);
					if(x >= mapWidth) break;
				}
				var z = 0;
				for(var s = 0; s < streetNum; s++){
					for(var i = 0; i < mapWidth; i++){
						if(mapGrid[i][z] == -1){
							mapGrid[i][z] = -3
						}
						else{
							mapGrid[i][z] = -2;
						}
					}
					z += randInt(2,5);
					if(z >= mapHeight) break;
				}
			}

			// generate a map
			function generateAlley() {
				var b,h,s,rot;

				for(var i = 0; i < mapWidth; i++){
					for(var j = 0; j < mapHeight; j++){
						var result = mapGrid[i][j];
						var pos = [i * buildingFootprint, j * buildingFootprint];

						if(result < -2){	//crossstreet
							s = street.clone();
							s.castShadow = true;
							s.receiveShadow = true;
							s.translateX(pos[0]);
							s.translateZ(pos[1]);
							scene.add( s );
						}
						if(result < -1 ){
							s = street.clone();
							s.castShadow = true;
							s.receiveShadow = true;
							s.translateX(pos[0]);
							s.translateZ(pos[1]);
							scene.add( s );
						}
						else if( result < 0 ){
							s = street.clone();
							s.castShadow = true;
							s.receiveShadow = true;
							s.translateX(pos[0]);
							s.translateZ(pos[1]);
							scene.add( s );
						}
						else
						{
							if(checkneighbor(i,j)){
								var r = randInt(0,buildings.length-1);	// randomly choose a building
								b = buildings[r].clone();
								b.castShadow = true;
								b.receiveShadow = true;
								b.translateX(pos[0]);
								b.translateZ(pos[1]);
								//rot = rotation[randInt(0,3)];
								rot = rotation[checkOrientation(i,j)];
								b.rotation.y = rot;
								scene.add( b );

								var newLight = new THREE.PointLight( 0xFFFFAA, 1, 100 );
								newLight.position.set( pos[0], 20, pos[1] );
								scene.add( newLight );

								// var sphereSize = 1;
								// var pointLightHelper = new THREE.PointLightHelper( newLight, sphereSize );
								// scene.add( pointLightHelper );

								// add the house aboveshop
								var r2 = randInt(0,houses.length-1);
								h = houses[r2].clone();
								h.castShadow = true;
								h.receiveShadow = true;
								h.translateX(pos[0]);
								h.translateZ(pos[1]);
								h.rotation.y = rot;
								scene.add( h );
							}
							else{
								continue;
							}
							
						}
						
					}
				}
			}
			// return true can place a house
			// return false
			// [r][c] 1 1
			// 1 [r][c] 1
			// 1 1 1
			function checkneighbor(row,col){
				if(row < 1 || col < 1 || row > mapWidth-2 || col > mapHeight-2){
					return true;
				}
				if(mapGrid[row-1][col-1] < 0){
					return true;
				}
				else if(mapGrid[row-1][col] < 0){
					return true;
				}
				else if(mapGrid[row-1][col+1] < 0){
					return true;
				}
				else if(mapGrid[row][col-1] < 0){
					return true;
				}
				else if(mapGrid[row][col+1] < 0){
					return true;
				}
				else if(mapGrid[row+1][col-1] < 0){
					return true;
				}
				else if(mapGrid[row+1][col] < 0){
					return true;
				}
				else if(mapGrid[row+1][col+1] < 0){
					return true;
				}
				return false;
			}
			function checkOrientation(row,col){
				if(row < 1 || col < 1 || row > mapWidth-2 || col > mapHeight-2){
					return 0;
				}
				if(mapGrid[row-1][col-1] < 0 && mapGrid[row-1][col] < 0 && mapGrid[row-1][col+1] < 0){
					return 1;
				}
				return 0;
				// else if(mapGrid[row-1][col] < 0){
				// 	return true;
				// }
				// else if(mapGrid[row-1][col+1] < 0){
				// 	return true;
				// }
				// else if(mapGrid[row][col-1] < 0){
				// 	return true;
				// }
				// else if(mapGrid[row][col+1] < 0){
				// 	return true;
				// }
				// else if(mapGrid[row+1][col-1] < 0){
				// 	return true;
				// }
				// else if(mapGrid[row+1][col] < 0){
				// 	return true;
				// }
				// else if(mapGrid[row+1][col+1] < 0){
				// 	return true;
				// }
				// return false;
			}

			function playerControls () {

				// Are the controls enabled? (Does the browser have pointer lock?)
				if ( controls.controlsEnabled ) {

					// Save the current time
					var time = performance.now();
					// Create a delta value based on current time
					var delta = ( time - prevTime ) / 1000;

					// Set the velocity.x and velocity.z using the calculated time delta
					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					// As velocity.y is our "gravity," calculate delta
					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					if ( controls.moveForward ) {
						velocity.z -= 400.0 * delta;
					}

					if ( controls.moveBackward ) {
						velocity.z += 400.0 * delta;
					}

					if ( controls.moveLeft ) {
						velocity.x -= 400.0 * delta;
					}

					if ( controls.moveRight ) {
						velocity.x += 400.0 * delta;
					}

					// Update the position using the changed delta
					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					// Prevent the camera/player from falling out of the 'world'
					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

					}

					// Save the time for future delta calculations
					prevTime = time;

				}
			}

			init();
			animate();

		</script>
	</body>
</html>