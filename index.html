<!DOCTYPE html>
<html lang="en">
	<head>
		<script src="js/three.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/FirstPersonControls.js"></script>
		<script src="js/FBXLoader.js"></script>
		<script src="js/inflate.min.js"></script>
	</head>
	<body>
		<script>

			var camera, scene, renderer;

			var floorGeometry, floorMaterial, floorMesh, floorTexture;
			var boxGeometry, boxMaterial, boxMesh, boxTexture;
			var controls;
			var light;

			var loadingManager;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			var buildings = [];
			var rotation = [0, -Math.PI/2, -Math.PI, -3*Math.PI/2];

			function init() {

				// Create a camera
				// 	Set a Field of View (FOV) of 75 degrees
				// 	Set an Apsect Ratio of the inner width divided by the inner height of the window
				//	Set the 'Near' distance at which the camera will start rendering scene objects to 2
				//	Set the 'Far' (draw distance) at which objects will not be rendered to 1000
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
				//camera.position.set( 100, 200, 300 );
				
				// 
				loadingManager = new THREE.LoadingManager();

				// SCENE
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0 );
				scene.fog = new THREE.Fog( 0xa0a0a0, 400, 1000 );

				// Create a HemisphereLight source
				light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				light.position.set( 0, 200, 0 );
				scene.add( light );
				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 200, 100 );
				light.castShadow = true;
				light.shadow.camera.top = 180;
				light.shadow.camera.bottom = - 100;
				light.shadow.camera.left = - 120;
				light.shadow.camera.right = 120;
				scene.add( light );

				// Create First Person Controls
				controls = new THREE.FirstPersonControls( camera );
				scene.add( controls.getObject() );

				// Create FLOOR
				var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );
				
				// GRID
				var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.material.transparent = true;
				scene.add( grid );
				
				// LOAD models
				loadModels();
				// PUT models into the scene
				//generateAlley();
				
				// Create a WebGL Renderer
				renderer = new THREE.WebGLRenderer();
				// Set the size of the renderer to the inner width and inner height of the window
				renderer.setSize( window.innerWidth, window.innerHeight );
				// Add in the created DOM element to the body of the document
				document.body.appendChild( renderer.domElement );

			}

			function animate() {

				// Call the requestAnimationFrame function on the animate function
				requestAnimationFrame( animate );
				//console.log(buildings.length);

				// Check the FirstPersonControls object and update velocity accordingly
				playerControls();
				//controls.getObject().translateX(0.1 );

				// Render everything using the created renderer, scene, and camera
				renderer.render( scene, camera );

			}

			// load my models for alley
			function loadModels() {
				loadingManager.onLoad = function ( ) {
					console.log( 'Loading complete!');
					generateAlley();
				};
				var loader = new THREE.FBXLoader(loadingManager);
				loader.load( 'models/shop1.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/shop2.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/shop3.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/shop4.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
				loader.load( 'models/shop5.fbx', function ( object ) {
					buildings.push(object);
				}, undefined, function ( e ) {
					console.error( e );
				} );
			}

			function randInt(min, max) { // min and max included 
				return Math.floor(Math.random() * (max - min + 1) + min);
			}

			// generate a map
			function generateAlley() {
				var mapWidth = 5;
				var mapHeight = 5;
				var buildingFootprint = 30;
				var b;

				for(var i = 0; i < mapHeight; i++){
					for(var j = 0; j < mapWidth; j++){
						var pos = [i * buildingFootprint,j * buildingFootprint]
						var r = randInt(0,4);
						console.log(r);
						b = buildings[r].clone();
						b.translateX(pos[0]);
						b.translateZ(pos[1]);
						b.rotation.y = rotation[randInt(0,3)];
						scene.add( b );
					}
				}
			}

			function playerControls () {

				// Are the controls enabled? (Does the browser have pointer lock?)
				if ( controls.controlsEnabled ) {

					// Save the current time
					var time = performance.now();
					// Create a delta value based on current time
					var delta = ( time - prevTime ) / 1000;

					// Set the velocity.x and velocity.z using the calculated time delta
					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					// As velocity.y is our "gravity," calculate delta
					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					if ( controls.moveForward ) {
						velocity.z -= 400.0 * delta;
					}

					if ( controls.moveBackward ) {
						velocity.z += 400.0 * delta;
					}

					if ( controls.moveLeft ) {
						velocity.x -= 400.0 * delta;
					}

					if ( controls.moveRight ) {
						velocity.x += 400.0 * delta;
					}

					// Update the position using the changed delta
					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					// Prevent the camera/player from falling out of the 'world'
					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

					}

					// Save the time for future delta calculations
					prevTime = time;

				}
			}

			init();
			animate();

		</script>
	</body>
</html>